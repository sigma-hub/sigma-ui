import fs from 'node:fs';
import path, { basename } from 'node:path';
import { template } from 'lodash-es';
import { rimraf } from 'rimraf';

import { baseColors, colorMapping, colors } from '../src/lib/registry/colors';
import { registrySchema } from '../src/lib/registry/schema';
import { styleSystems } from '../src/lib/registry/style-system';
import { buildRegistry } from '../src/lib/registry/registry';
import {
  TAILWIND_STYLES_TEMPLATE,
  TAILWIND_STYLES_WITH_VARS_TEMPLATE,
} from '~/packages/shared/templates/tailwind-styles';
import {
  CSS_STYLES_WITH_VARS_TEMPLATE,
} from '~/packages/shared/templates/css-styles';

const REGISTRY_PATH = path.join(process.cwd(), '../../packages/cli/__generated/registry-schemes');
const REGISTRY_IGNORE = ['super-form'];
const newLine = '\n';

async function validateRegistry() {
  const registry = await buildRegistry();
  const result = registrySchema.safeParse(registry);

  if (!result.success) {
    console.error(result.error);
    process.exit(1);
  }

  return result.data;
}

function buildGeneratedIndex(registryData: any) {
  let index = `
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
export const Index = {
`;

  for (const style of styleSystems) {
    index += `  "${style.name}": {`;

    for (const item of registryData) {
      if (item.type === 'components:ui') {
        continue;
      }

      const resolveFiles = item.files.map(
        (file: string) => `../../../packages/lib/src/registry/${style.name}/${file}`,
      );

      index += `
    "${item.name}": {
      name: "${item.name}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      component: () => import("${resolveFiles[0]}").then((m) => m.default),
      files: [${resolveFiles.map((file: string) => `"${file}"`)}],
    },`;
    }

    index += `
  },`;
  }

  index += `
}
`;

  rimraf.sync(path.join(process.cwd(), '__generated/index.ts'));
  fs.writeFileSync(path.join(process.cwd(), '__generated/index.ts'), index);
}

function buildStylesRegistry(registryData: any) {
  for (const styleSystem of styleSystems) {
    const targetPath = path.join(REGISTRY_PATH, 'style-system', styleSystem.name);

    if (!fs.existsSync(targetPath)) {
      fs.mkdirSync(targetPath, { recursive: true });
    }

    for (const item of registryData) {
      if (item.type !== 'components:ui') {
        continue;
      }

      const files = item.files?.map((file: string) => {
        let content = fs.readFileSync(
          path.join(process.cwd(), '../../packages/lib/src/registry', styleSystem.name, 'ui', file),
          'utf8',
        );

        content = content.replace(/\r\n/g, newLine);

        return {
          name: basename(file),
          content,
        };
      });

      const payload = {
        ...item,
        files,
      };

      const payloadStr = JSON.stringify(payload, null, 2).replace(/\r\n/g, newLine);

      fs.writeFileSync(
        path.join(targetPath, `${item.name}.json`),
        payloadStr,
        'utf8',
      );
    }
  }

  const styleSystemsJson = JSON.stringify(styleSystems, null, 2);
  fs.writeFileSync(
    path.join(REGISTRY_PATH, 'style-system/index.json'),
    styleSystemsJson,
    'utf8',
  );
}

function buildRegistryIndex(registryData: any) {
  const names = registryData.filter(
    (item: any) =>
      item.type === 'components:ui' && !REGISTRY_IGNORE.includes(item.name),
  );
  const registryJson = JSON.stringify(names, null, 2);
  rimraf.sync(path.join(REGISTRY_PATH, 'index.json'));
  fs.writeFileSync(path.join(REGISTRY_PATH, 'index.json'), registryJson, 'utf8');
}

function processColorData(value: any) {
  if (typeof value === 'string') {
    return value;
  }

  if (Array.isArray(value)) {
    return value.map(item => ({
      ...item,
      rgbChannel: item.rgb.replace(/^rgb\((\d+),(\d+),(\d+)\)$/, '$1 $2 $3'),
      hslChannel: item.hsl.replace(/^hsl\(([\d.]+),([\d.]+%),([\d.]+%)\)$/, '$1 $2 $3'),
    }));
  }

  if (typeof value === 'object') {
    return {
      ...value,
      rgbChannel: value.rgb.replace(/^rgb\((\d+),(\d+),(\d+)\)$/, '$1 $2 $3'),
      hslChannel: value.hsl.replace(/^hsl\(([\d.]+),([\d.]+%),([\d.]+%)\)$/, '$1 $2 $3'),
    };
  }
}

function buildColorsRegistry() {
  const colorsTargetPath = path.join(REGISTRY_PATH, 'colors');
  rimraf.sync(colorsTargetPath);

  if (!fs.existsSync(colorsTargetPath)) {
    fs.mkdirSync(colorsTargetPath, { recursive: true });
  }

  const colorsData: Record<string, any> = {};

  for (const [color, value] of Object.entries(colors)) {
    colorsData[color] = processColorData(value);
  }

  fs.writeFileSync(
    path.join(colorsTargetPath, 'index.json'),
    JSON.stringify(colorsData, null, 2),
    'utf8',
  );

  return colorsData;
}

function buildBaseColors(colorsData: Record<string, any>) {
  for (const baseColor of baseColors.map(item => item.name)) {
    const base: Record<string, any> = {
      inlineColors: {},
      cssVars: {},
      templates: {
        tailwind: {
          withVariables: '',
        },
        css: {
          withVariables: '',
        },
      },
    };

    for (const [mode, values] of Object.entries(colorMapping)) {
      base.inlineColors[mode] = {};
      base.cssVars[mode] = {};

      for (const [key, value] of Object.entries(values)) {
        if (typeof value === 'string') {
          const resolvedColor = value.replace(/\{\{base\}\}-/g, `${baseColor}-`);
          base.inlineColors[mode][key] = resolvedColor;

          const [resolvedBase, scale] = resolvedColor.split('-');
          const color = scale
            ? colorsData[resolvedBase].find(
                (item: any) => item.scale === Number.parseInt(scale),
              )
            : colorsData[resolvedBase];

          if (color) {
            base.cssVars[mode][key] = color.hslChannel;
          }
        }
      }
    }

    const config = {
      colors: base.cssVars,
      sizes: {
        radius: 0.5,
      },
    };

    base.templates.tailwind.withVariables = template(TAILWIND_STYLES_WITH_VARS_TEMPLATE)(config);
    base.templates.css.withVariables = template(CSS_STYLES_WITH_VARS_TEMPLATE)(config);

    fs.writeFileSync(
      path.join(REGISTRY_PATH, `colors/${baseColor}.json`),
      JSON.stringify(base, null, 2),
      'utf8',
    );
  }
}

async function main() {
  const registryData = await validateRegistry();
  buildGeneratedIndex(registryData);
  buildStylesRegistry(registryData);
  buildRegistryIndex(registryData);
  const colorsData = buildColorsRegistry();
  buildBaseColors(colorsData);
  console.log('âœ… Done');
}

main().catch(console.error);
